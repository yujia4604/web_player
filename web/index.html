<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å®æ—¶å­—å¹•è§†é¢‘æ’­æ”¾å™¨</title>
    <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet"/>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            flex-direction: column;
            font-family: Arial, sans-serif;
        }
        .video-js .vjs-text-track-display {
            bottom: 3em;
            font-size: 1.2em;
            color: white;
            text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8);
        }
        #video-upload-container {
            text-align: center;
            margin: 20px 0;
        }
        #video-upload {
            display: none;
        }
        .upload-button {
            display: inline-flex;
            align-items: center;
            padding: 12px 24px;
            background-color: #007bff;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .upload-button:hover {
            background-color: #0056b3;
        }
        .upload-icon {
            margin-right: 8px;
            font-size: 20px;
        }
        #my-video {
            display: none;
            margin: 20px auto;
        }
        #my-video.show {
            display: block;
        }
        hr {
            width: 80%;
            margin: 20px auto;
            border: 0;
            border-top: 1px solid #ccc;
        }
    </style>
</head>
<body>
<div id="video-upload-container">
    <label for="video-upload" class="upload-button">
        <span class="upload-icon">ğŸ“</span> ä¸Šä¼ è§†é¢‘
    </label>
    <input type="file" id="video-upload" accept="video/mp4"/>
</div>
<video id="my-video" class="video-js" controls preload="auto" width="800" height="600">
    <track kind="subtitles" src="/subtitles.vtt" srclang="en" label="è‹±æ–‡" default/>
    <p class="vjs-no-js">è¯·å¯ç”¨ JavaScript ä»¥è§‚çœ‹è§†é¢‘ã€‚</p>
</video>

<script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
<script>
    // åˆå§‹åŒ– Video.js æ’­æ”¾å™¨
    const player = videojs('my-video', {
        textTrackSettings: {
            color: 'white',
            backgroundColor: 'black',
            fontPercent: 1.2
        }
    });

    // æ—¶é—´æˆ³æ ¼å¼åŒ–å‡½æ•°ï¼ˆå°†ç§’è½¬æ¢ä¸ºç§’æ•°ï¼Œç”¨äº VTTCueï¼‰
    function parseTimestamp(seconds) {
        return parseFloat(seconds.replace(',', '.')); // å¤„ç† 6,380 -> 6.380
    }

    // è·å–æˆ–åˆ›å»ºå­—å¹•è½¨é“
    let subtitleTrack = null;
    const textTracks = player.textTracks();
    for (let i = 0; i < textTracks.length; i++) {
        if (textTracks[i].kind === 'subtitles' && textTracks[i].srclang === 'en') {
            subtitleTrack = textTracks[i];
            break;
        }
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­—å¹•è½¨é“ï¼ŒåŠ¨æ€æ·»åŠ ä¸€ä¸ªæœ¬åœ°å­—å¹•è½¨é“
    if (!subtitleTrack) {
        try {
            subtitleTrack = player.addTextTrack('subtitles', 'è‹±æ–‡', 'en');
            console.log('å­—å¹•è½¨é“åˆ›å»ºæˆåŠŸ:', subtitleTrack);
        } catch (error) {
            console.error('åˆ›å»ºå­—å¹•è½¨é“å¤±è´¥:', error);
        }
    }

    // ç¡®ä¿å­—å¹•è½¨é“æ˜¾ç¤º
    if (subtitleTrack) {
        subtitleTrack.mode = 'showing';
    } else {
        console.error('å­—å¹•è½¨é“åˆå§‹åŒ–å¤±è´¥');
    }

    // WebSocket è¿æ¥
    let ws = null;
    let currentTime = 0; // è®°å½•å½“å‰è§†é¢‘æ—¶é—´ç‚¹
    let lastStartTime = -1; // è®°å½•ä¸Šæ¬¡å‘é€çš„å¼€å§‹æ—¶é—´ç‚¹

    // å®šä¹‰ WebSocket äº‹ä»¶å¤„ç†ç¨‹åº
    function setupWebSocket() {
        ws = new WebSocket('ws://192.168.1.17:8000/ws/subtitles');

        ws.onopen = () => {
            console.log('WebSocket è¿æ¥å·²å»ºç«‹');
        };

        ws.onmessage = (event) => {
            const subtitleData = JSON.parse(event.data);
            console.log('Received subtitle data:', subtitleData); // è°ƒè¯•è¾“å‡º
            const textTracks = player.textTracks();
            for (let i = 0; i < textTracks.length; i++) {
                if (textTracks[i].kind === 'subtitles' && textTracks[i].language === 'en') {
                    subtitleTrack = textTracks[i];
                    break;
                }
            }
            if (!subtitleTrack) {
                try {
                    subtitleTrack = player.addTextTrack('subtitles', 'è‹±æ–‡', 'en');
                    console.log('å­—å¹•è½¨é“åˆ›å»ºæˆåŠŸ:', subtitleTrack);
                } catch (error) {
                    console.error('åˆ›å»ºå­—å¹•è½¨é“å¤±è´¥:', error);
                }
            }
            if (subtitleData.type === 'subtitle' && subtitleTrack) {
                // è§£ææ—¶é—´æˆ³
                const start = parseTimestamp(subtitleData.start);
                const end = parseTimestamp(subtitleData.end);
                const text = subtitleData.text.trim();

                // åˆ›å»ºæ–°çš„ VTTCue
                try {
                    const cue = new VTTCue(start, end, text);
                    // æ·»åŠ æ–°çš„ cue åˆ°å­—å¹•è½¨é“
                    subtitleTrack.addCue(cue);
                    console.log('Added cue:', { start, end, text });
                } catch (error) {
                    console.error('æ·»åŠ å­—å¹• cue å¤±è´¥:', error);
                }

                subtitleTrack.mode = 'showing';
            }
        };

        ws.onclose = () => {
            console.log('WebSocket è¿æ¥å·²å…³é—­');
        };

        ws.onerror = (error) => {
            console.error('WebSocket é”™è¯¯:', error);
        };

        return ws;
    }

    // å¤„ç†è§†é¢‘æ–‡ä»¶ä¸Šä¼ 
    const videoUpload = document.getElementById('video-upload');
    videoUpload.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
            // æ˜¾ç¤ºè§†é¢‘æ’­æ”¾å™¨
            document.getElementById('my-video').classList.add('show');

            // è®¾ç½®è§†é¢‘æ’­æ”¾å™¨æºä¸ºç”¨æˆ·ä¸Šä¼ çš„æ–‡ä»¶
            const videoUrl = URL.createObjectURL(file);
            player.src({src: videoUrl, type: file.type || 'video/mp4'});
            player.load(); // ç¡®ä¿æ’­æ”¾å™¨åŠ è½½æ–°è§†é¢‘
            console.log('è§†é¢‘æºå·²è®¾ç½®ä¸º:', videoUrl);

            // åˆå§‹åŒ– WebSocket
            ws = setupWebSocket();

            // åˆ†ç‰‡å‘é€è§†é¢‘æ–‡ä»¶
            const chunkSize = 1024 * 1024 * 60; // æ¯ç‰‡ 60MB
            const reader = new FileReader();

            const sendVideoFromTime = async (startTime) => {
                // ç­‰å¾… WebSocket è¿æ¥å»ºç«‹
                if (ws.readyState !== WebSocket.OPEN) {
                    await new Promise((resolve) => {
                        ws.onopen = () => {
                            console.log('WebSocket è¿æ¥å·²å°±ç»ª');
                            resolve();
                        };
                        ws.onerror = () => {
                            console.error('WebSocket è¿æ¥å¤±è´¥');
                            resolve(); // å³ä½¿å¤±è´¥ä¹Ÿç»§ç»­ï¼Œé¿å…é˜»å¡
                        };
                    });
                }

                // è®¡ç®—èµ·å§‹å­—èŠ‚ï¼ˆå‡è®¾è§†é¢‘æ¯”ç‰¹ç‡å‡åŒ€ï¼Œè¿‘ä¼¼è®¡ç®—ï¼‰
                const videoDuration = player.duration() || 0; // è§†é¢‘æ€»æ—¶é•¿ï¼ˆç§’ï¼‰
                const fileSize = file.size; // æ–‡ä»¶æ€»å¤§å°ï¼ˆå­—èŠ‚ï¼‰
                const bytesPerSecond = videoDuration ? fileSize / videoDuration : 0;
                const offset = 0; // èµ·å§‹å­—èŠ‚ä½ç½®
                let currentOffset = offset;

                const sendNextChunk = () => {
                    const slice = file.slice(currentOffset, currentOffset + chunkSize);
                    reader.readAsArrayBuffer(slice);
                };

                reader.onload = async () => {
                    const chunk = reader.result; // ArrayBuffer
                    if (startTime !== lastStartTime && ws.readyState === WebSocket.OPEN) {
                        lastStartTime = startTime; // æ›´æ–°ä¸Šæ¬¡å‘é€çš„å¼€å§‹æ—¶é—´ç‚¹
                        console.log(`å‘é€ seek changed: ${startTime}s`);
                        ws.send(JSON.stringify({type: 'seek', time: startTime})); // é€šçŸ¥åç«¯æ–°çš„æ—¶é—´ç‚¹
                    }
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(chunk); // å‘é€åˆ†ç‰‡
                        console.log(`å‘é€åˆ†ç‰‡: ${currentOffset} - ${currentOffset + chunk.byteLength}, æ—¶é—´: ${startTime}s`);
                        currentOffset += chunk.byteLength;
                        if (currentOffset < file.size) {
                            // ç»§ç»­å‘é€ä¸‹ä¸€ç‰‡
                            sendNextChunk();
                        } else {
                            // å‘é€å®Œæˆæ ‡å¿—
                            ws.send(JSON.stringify({type: 'end'}));
                            console.log('è§†é¢‘æ–‡ä»¶åˆ†ç‰‡å‘é€å®Œæˆ');
                        }
                    } else {
                        console.warn('WebSocket æœªè¿æ¥ï¼Œåœæ­¢å‘é€åˆ†ç‰‡');
                    }
                };

                reader.onerror = (error) => {
                    console.error('è¯»å–è§†é¢‘æ–‡ä»¶åˆ†ç‰‡å¤±è´¥:', error);
                };

                // å¼€å§‹å‘é€ä»æŒ‡å®šæ—¶é—´ç‚¹çš„åˆ†ç‰‡
                sendNextChunk();
            };

            // åˆæ¬¡ä¸Šä¼ æ—¶ä»å¤´å¼€å§‹å‘é€
            await sendVideoFromTime(0);

            // ç›‘å¬è¿›åº¦æ¡æ‹–åŠ¨äº‹ä»¶
            player.on('seeking', async () => {
                console.log('seeking called');
                const newTime = player.currentTime();
                if (newTime !== currentTime) {
                    console.log(`è§†é¢‘è¿›åº¦æ¡æ‹–åŠ¨åˆ°: ${newTime}s`);
                    currentTime = newTime;
                    // å…³é—­ç°æœ‰ WebSocket è¿æ¥
                    if (ws && ws.readyState !== WebSocket.CLOSED && ws.readyState !== WebSocket.CLOSING) {
                        console.log('å…³é—­ç°æœ‰ WebSocket è¿æ¥', ws.readyState);
                        ws.close();
                    }
                    // æ¸…ç©ºç°æœ‰å­—å¹•
                    if (subtitleTrack) {
                        while (subtitleTrack.cues && subtitleTrack.cues.length > 0) {
                            subtitleTrack.removeCue(subtitleTrack.cues[0]);
                        }
                    }
                    // åˆ›å»ºæ–°çš„ WebSocket è¿æ¥
                    ws = setupWebSocket();
                    // ä»æ–°çš„æ—¶é—´ç‚¹å¼€å§‹å‘é€è§†é¢‘
                    await sendVideoFromTime(newTime);
                }
            });
        }
    });
</script>
</body>
</html>